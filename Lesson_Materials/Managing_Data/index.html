<!DOCTYPE html>

<html>
	<head>
	    <meta charset="utf-8">
		<link rel="stylesheet" href="../common-revealjs/css/reveal.css">
		<link rel="stylesheet" href="../common-revealjs/css/theme/white.css">
		<link rel="stylesheet" href="../common-revealjs/css/highlight/styles/stackoverflow-light.css">
		<link rel="stylesheet" href="../common-revealjs/css/custom.css">
		<script>
			// This is needed when printing the slides to pdf
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? '../common-revealjs/css/print/pdf.css' : '../common-revealjs/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<script>
		    // This is used to display the static images on each slide,
			// See global-images in this html file and custom.css
			(function() {
				if(window.addEventListener) {
					window.addEventListener('load', () => {
						let slides = document.getElementsByClassName("slide-background");

						if (slides.length === 0) {
							slides = document.getElementsByClassName("pdf-page")
						}

						// Insert global images on each slide
						for(let i = 0, max = slides.length; i < max; i++) {
							let cln = document.getElementById("global-images").cloneNode(true);
							cln.removeAttribute("id");
							slides[i].appendChild(cln);
						}

						// Remove top level global images
						let elem = document.getElementById("global-images");
						elem.parentElement.removeChild(elem);
					}, false);
				}
			})();
		</script>
	</head>

	<body>
		<div class="reveal">
			<div class="slides">
				<div id="global-images" class="global-images">
					<img src="../common-revealjs/images/sycl_academy.png" />
					<img src="../common-revealjs/images/sycl_logo.png" />
					<img src="../common-revealjs/images/trademarks.png" />
					<img src="../common-revealjs/images/nhr-sw.png" />
				</div>
				<!--Slide 1-->
				<section class="hbox" data-markdown>
					## Managing Data
				</section>
				<!--Slide 2-->
				<section class="hbox" data-markdown>
					## Learning Objectives
					* Learn about the USM data management model
					* Learn how to allocate, transfer and free memory using USM.
					* Learn how to access data in a kernel function
					* Learn about the variations of USM
					* Learn about the kinds of USM memory allocations
				</section>
				<section>
					<div class="hbox" data-markdown>
						#### Memory Models
					</div>
					<div class="container" data-markdown>
						* In SYCL there are two models for managing data:
						  * The buffer/accessor model.
						  * The USM (unified shared memory) model &larr; *we will focus on this*.
						* Which model you choose can have an effect on how you enqueue kernel functions.
					</div>
				</section>
				<!--Slide 3-->
				<!--Slide 3A-->
				<section>
					<div class="hbox" data-markdown>
						#### CPU and GPU Memory
					</div>
					<div class="container" data-markdown>
						* A GPU has its own memory, separate to CPU memory.
						* In order for the GPU to use memory from the CPU, the following actions must take place (either explicitly or implicitly):
						    * Memory allocation on the GPU.
						    * Data migration from the CPU to the allocation on the GPU.
						    * Some computation on the GPU.
						    * Migration of the result back to the CPU.
					</div>
					<img src="../common-revealjs/images/gpu_cpu_memory.png" height="400">
				</section>
				<!--Slide 3A-->
				<section>
					<div class="hbox" data-markdown>
						#### CPU and GPU Memory
					</div>
					<div class="container" data-markdown>
						* Memory transfers between CPU and GPU are a bottleneck.
						* We want to minimize these transfers, when possible.
					</div>
					<img src="../common-revealjs/images/gpu_cpu_memory.png" height="400">
				</section>
				
				<section>
					<div class="hbox" data-markdown>
						#### Unified virtual address space
					</div>
					<div class="container">
						<div class="col" data-markdown>
							![SYCL](../common-revealjs/images/unified_virtual_address_space.png "SYCL")
						</div>
						<div class="col" data-markdown>
							* USM memory allocations return pointers which are consistent between the host application and kernel functions on a device
							* Representing data between the host and device(s) does not require creating accessors
							* Pointer-based API more familiar to C or C++ programmers
						</div>
					</div>
				</section>
				<!--Slide 5-->
				<section>
					<div class="hbox" data-markdown>
						#### Pointer based structures
					</div>
					<div class="container">
						<div class="col" data-markdown>
							![SYCL](../common-revealjs/images/pointer_based_structures.png "SYCL")
						</div>
						<div class="col" data-markdown>
							* Data is moved between the host and device(s) in a span of memory in bytes rather than a buffer of a specific type
							* Pointers within that region of memory can freely point to any other address in that region
							* Easier to port existing C or C++ code to use SYCL
						</div>
					</div>
				</section>
				<!--Slide 6-->
				<section>
					<div class="hbox" data-markdown>
						#### Explicit memory management
					</div>
					<div class="container">
						<div class="col" data-markdown>
							![SYCL](../common-revealjs/images/explicit_data_movement.png "SYCL")
						</div>
						<div class="col" data-markdown>
							* Memory is allocated and data is moved using explicit routines
							* Moving data between the host and device(s) does not require accessors or submitting command groups
							* The SYCL runtime will not perform any data dependency analysis, dependencies between commands must be managed manually
						</div>
					</div>
				</section>
				<!--Slide 7-->
				<section>
					<div class="hbox" data-markdown>
						#### Shared memory allocations
					</div>
					<div class="container">
						<div class="col" data-markdown>
							![SYCL](../common-revealjs/images/shared_memory.png "SYCL")
						</div>
						<div class="col" data-markdown>
							* Some platforms will support variants of USM where memory allocations share the same memory region between the host and device(s)
							* No explicit routines are required to move the data between the host and device(s)
						</div>
					</div>
				</section>
				<!--Slide 8-->
				<section>
					<div class="hbox" data-markdown>
						#### USM allocation types
					</div>
					<div class="container" data-markdown>
						USM has three different kinds of memory allocation
					</div>
					<div class="container" data-markdown>
						* A **host** allocation is allocated in host memory
						* A **device** allocation is allocation in device memory
						* A **shared** allocation is allocated in shared memory and can migrate back and forth
					</div>
				</section>
				<!--Slide 9-->
				<section>
					<div class="hbox" data-markdown>
						#### USM variants
					</div>
					<div class="container" data-markdown>
						USM has four variants which a platform can support with varying levels of support
					</div>
					<div class="container" data-markdown>
						![SYCL](../common-revealjs/images/usm_variants.png "SYCL")
					</div>
				</section>
				<!--Slide 10-->
				<section>
					<div class="hbox" data-markdown>
						#### Querying for support
					</div>
					<div class="container" data-markdown>
						Each SYCL platform and its device(s) will support
						different variants of USM and different kinds of memory allocation
					</div>
					<pre><code>if (dev.has(sycl::aspect::usm_device_allocations))</code></pre>
				</section>
				<!--Slide 3-->
				<section>
					<div class="hbox" data-markdown>
						#### Using USM - Malloc Device
					</div>
					<div class="container">
						<pre class="cpp"><code class="code-100pc">// Allocate memory on device
T *device_ptr = sycl::malloc_device&lt;T&gt;(n, myQueue);

// Copy data to device
myQueue.memcpy(device_ptr, cpu_ptr, n * sizeof(T));

// ...
// Do some computation on device
// ...

// Copy data back to CPU
myQueue.memcpy(result_ptr, device_ptr, n * sizeof(T)).wait();

// Free allocated data
sycl::free(device_ptr, myQueue);</code></pre>
					</div>
					<div class="container" data-markdown>
						* It is important to free memory after it has been 
						used to avoid memory leaks.
					</div>
				</section>
				<section>
					<div class="hbox" data-markdown>
						#### Using USM - Malloc Shared
					</div>
					<div class="container">
						<pre class="cpp"><code class="code-100pc">// Allocate shared memory 
T *shared_ptr = sycl::malloc_shared&lt;T&gt;(n, myQueue);

// Shared memory can be accessed on host as well as device
for (auto i = 0; i &lt; n; ++i)
  shared_ptr[i] = i;

// ...
// Do some computation on device
// ...

// Free allocated data
sycl::free(shared_ptr, myQueue);</code></pre>
					</div>
					<div class="container" data-markdown>
						* Shared memory is accessible on host and device.
						* Performance of shared memory accesses may be poor depending on platform.
					</div>
				</section>
				<!--Slide 20-->
				<section>
					<div class="hbox" data-markdown>
						## Questions
					</div>
				</section>
				<!--Slide 21-->
				<section>
					<div class="hbox" data-markdown>
						#### Exercise
					</div>
					<div class="container" data-markdown>
						Code_Exercises/Managing_Data/source
					</div>
					<div class="container" data-markdown>
						Implement a SYCL application that adds two variables
						and returns the result.  
						Use USM to manage memory.
					</div>
				</section>
			</div>
		</div>
		<script src="../common-revealjs/js/reveal.js"></script>
		<script src="../common-revealjs/plugin/markdown/marked.js"></script>
		<script src="../common-revealjs/plugin/markdown/markdown.js"></script>
		<script src="../common-revealjs/plugin/notes/notes.js"></script>
		<script>
			Reveal.initialize({
				dependencies: [{src: '../common-revealjs/plugin/highlight/highlight.js', async: true}]
			});
			Reveal.configure({ slideNumber: true });
		</script>
	</body>
</html>
